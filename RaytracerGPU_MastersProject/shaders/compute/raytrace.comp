#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

#include "../include/definitions.glsl"
#include "../include/random.glsl"

layout(binding = 0) uniform ParameterUBO {
	vec3 camPos;
	vec3 camDir;
	uint currentSample;
	uint numTriangles;
	uint numSpheres;
	uint maxRayTraceDepth;
} ubo;

layout(binding = 1, rgba8) uniform image2D outputImage;

layout(binding = 2, rgba8) uniform image2D accumulationImage;

layout(std430, binding = 3) readonly buffer TriangleBufferObject {
	Triangle triangles[ ];
};

layout(std430, binding = 4) readonly buffer SpheresBufferObject {
	Sphere spheres[ ];
};

layout(std430, binding = 5) readonly buffer MaterialBufferObject {
	Material materials[ ];
};

layout(std430, binding = 6) readonly buffer LightsBufferObject {
	Light lights[ ];
};



// constants
const float VERTICAL_FOV = 30;
const float FOCAL_LENGTH = 1.0f;

const vec2 imageDimensions = vec2(imageSize(outputImage));
const float theta = VERTICAL_FOV * pi / 180.0f;
const float h = tan(theta / 2);
const float viewportHeight = 2.0f * h;
const float viewportWidth = imageDimensions.x / imageDimensions.y * viewportHeight;
const vec3 horizontalDir = vec3(viewportWidth, 0, 0);
const vec3 verticalDir = vec3(0, -viewportHeight, 0);
const vec3 origin = ubo.camPos * ubo.camDir;
const vec3 bottomLeftCorner = origin - (horizontalDir / 2) - (verticalDir / 2) - vec3(0, 0, FOCAL_LENGTH);


// get point along ray at t time
vec3 pointOnRayWithT(in Ray r, in float t) {
	return r.origin + t * r.direction;
}

// get a random point on a triangle in the triangles array
//vec3 randomOnTriangle(uint triangleIndex) {
//	float a = random();
//	float b = random(0, 1.0 - a); // sum of a + b must be <= 1.0 to be on the triangle
//	return triangles[triangleIndex].Quv[0] + a * triangles[triangleIndex].Quv[1] + b * triangles[triangleIndex].Quv[2];
//}

bool scatter(in Ray rIn, in HitRecord rec, out vec3 albedo, out ray scattered) {
	albedo = materials[rec.materialIndex].albedo;
	scattered = Ray(rec.p, normalize(random_in_hemisphere(rec.normal)));
	return materials[rec.materialIndex].materialType == LIGHT_MATERIAL;
}

// https://github.com/silvercorked/RaytracerInAWeekend/blob/main/Raytracer/Triangle.hpp#L77 see comment here for math
bool triangleHit(in uint triangleIndex, in Ray r, in float tMin, in float tMax, inout HitRecord rec) {
	Triangle tri = triangles[triangleIndex];
	vec3 u = tri.v1 - tri.v0;
	vec3 v = tri.v2 - tri.v0;
	vec3 triNormalUnnormalized = cross(u, v);
	vec3 triNormal = normalize(triNormalUnnormalized);
	float D = dot(triNormal, tri.Quv[0]);
	vec3 w = triNormalUnnormalized / dot(triNormalUnnormalized, triNormalUnnormalized);
	float denom = dot(triNormal, r.direction);
	if (abs(denom) < 0.0001) return false; // too close to parallel (and likely dont hit anyway)
	
	float t = (D - dot(triNormal, r.origin)) / denom;
	if (t < tMin || t > tMax) return false; // outside interval
	
	vec3 possIntersectionPoint = pointOnRayWithT(r, t);
	vec3 pointOnPlane = possIntersectionPoint - tri.v0;
	float a = dot(w, cross(pointOnPlane, v);
	float b = dot(w, cross(u, pointOnPlane));
	if (!(a < 0 || b < 0 || a + b > 1)) return false; // miss
	
	rec.t = t;
	rec.p = possIntersectionPoint;
	rec.u = u;
	rec.v = v;

	rec.normal = triNormal;
	rec.backFaceInt = dot(r.direction, rec.normal) > 0 ? 1 : 0;
	rec.normal *= 1 - 2 * rec.backFaceInt; // * -1 if backface, * 1 otherwise
	
	rec.materialIndex = tri.materialIndex;
	return true;
}

// https://github.com/silvercorked/RaytracerInAWeekend/blob/main/Raytracer/Sphere.hpp#L86 see comment here for math
bool sphereHit(in uint sphereIndex, in Ray r, in float tMin, in float tMax, inout HitRecord rec) {
	Sphere s = spheres[sphereIndex];
	vec3 oc = r.origin - s.center;
	float a = dot(r.direction, r.direction);
	float halfB = dot(oc, r.direction);
	float c = dot(oc, oc) - (s.radius * s.radius);
	float underRadical = halfB * halfB - a * c;
	if (underRadical < 0) return false;
	
	float radical = sqrt(underRadical);
	float root = (-halfB - radical) / a;
	if (root < tMin || root > tMax) { // missed, so try other root
		root = (-halfB + radical) / a;
		if (root < tMin || root > tMax)
			return false;
	}

	rec.t = root;
	rec.p = pointOnRayWithT(r, rec.t);
	// https://github.com/silvercorked/RaytracerInAWeekend/blob/main/Raytracer/Sphere.hpp#L64 for math (uses sphereical coords theta and phi)
	rec.u = (atan2(-s.center.z, s.center.x) + pi) / (2 * pi);
	rec.v = acos(-s.center.y) / pi;

	rec.normal = (rec.p - s.center) / radius;
	rec.backFaceInt = dot(r.direction, rec.normal) > 0 ? 1 : 0;
	rec.normal *= 1 - 2 * rec.backFaceInt; // * -1 if backface, * 1 otherwise

	rec.materialIndex = s.materialIndex;
}

bool sceneHit(in Ray r, out HitRecord rec) {
	float tMin = 0.001;
	float tMax = 10000;
	HitRecord temp;
	bool hitAny = false;
	float closestSoFar = tMax;
	for (uint i = 0; i < ubo.numTriangles; i++) {
		if (triangleHit(i, r, tMin, closestSoFar, temp)) {
			hitAny = true;
			closestSoFar = temp.t;
			rec = temp;
		}
	}
	for (uint i = 0; i < ubo.numSpheres; i++) {
		if (sphereHit(i, r, tMin, closestSoFar, temp)) {
			hitAny = true;
			closestSoFar = temp.t;
			rec = temp;
		}
	}
	return hitAny;
}

vec3 rayColor(inout Ray r) {
	vec3 unitDir = normalize(r.dir);
	HitRecord rec;
	vec3 finalColor = vec3(1.0);
	Ray curr = { r.origin, unitDir };
	for (uint i = 0; i < maxRayTraceDepth; i++) {
		if (sceneHit(curr, rec)) {
			vec3 albedo;
			bool emits = scatter(curr, rec, albedo, curr);
			finalColor *= albedo;
			if (emits)
				break;
		}
		else {
			finalColor *= 0.0; // background
		}
	}
	return finalColor;
}

// create a ray based on x and y coords of camera quad
Ray getRay(in vec2 xy) {
	vec2 uv = xy / imageDimensions.xy;
	return Ray(origin, bottomLeftCorner + uv.x * horizontalDir + uv.y * verticalDir);
}

// vkCmdDispatch(commandBuffer, (outImageWidth * n) / 32, (outImageHeight * n) / 32, 1); // will do n ray casts per pixel of output image
void main() { // gl_GlobalInvocationID.xy represents pixel locations
	Ray r = getRay(gl_GlobalInvocationID.xy);
	// get ray color
	vec3 pixelColor = rayColor(r);
	// add gathered color to outputImage's current color
	vec4 currentColor = imageLoad(accumulationImage, ivec2(gl_GlobalInvocationID.xy)).rgba * min(float(ubo.currentSample), 1.0);
	vec4 newColor = (vec4(pixelColor, 1.0) + currentColor * ubo.currentSample) / (float(ubo.currentSample) + 1.0);
	imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), newColor);
	// another pass may be needed for adding the gamma-correction term, as the entire image needs to be done
	// (see color.hpp in Raytracer project)
}
